<!DOCTYPE html>	
<html>
<head>
	<meta charset="utf-8">
	<title>Tanks</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" type="text/css" href="../game-main.css">
	<link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,700|Source+Code+Pro:400,700&amp;subset=cyrillic" rel="stylesheet">
	<script>
		function addQueryParam(k, v) {
			if (location.href.indexOf('?')<0)
				return (location.href += '?'+k+'='+v);
			var p = location.href.substring(location.href.indexOf('?')+1).split(/\&/g), query = "", w = false;
			for (var i = 0; i < p.length; ++i) {
				var key = p[i].split('=')[0];
				var value = p[i].indexOf('=')>=0?p[i].substring(p[i].indexOf('=')+1):'';
				if (key == k) {
					value = v;
					w = true;
		        }
				query += (i > 0 ? '&' : '') + key + '=' + value;
			}
			if (!w)
				query += (query.length==0?'':'&') + key + '=' + value;
			location.href = location.href.substring(0, location.href.indexOf('?')) + '?' + query;
		}
	</script>
</head>
<body>
	<div id="game">
		<div id="field">
			<canvas></canvas>
			<div id="control">
				
			</div>
		</div>
	</div>
	<div id="workspace">
		<div id="resizer"></div>
		<div id='tabs'>
			<!--div style='position:absolute;top:1em;right:0.25em;opacity:0.3;z-index:0;font-size:75%'><b>Alt</b>+<b>-</b>, <b>Alt</b>+<b>+</b> (зум в редакторе)</div-->
			<div class='tab' id="tab-code">Код</div><div class='tab active' id="tab-docs">Документация</div><div class='tab' id="tab-client">Клиент</div><div class='tab' id="tab-scoreboard">Таблица</div>
		</div>
		<div id="content">
			<div class="section" id="code">
				<div id="editor"></div>
			</div>
			<div class="section active" id="docs">
# Документация

### _bodjo/tanks_

## Правила игры
Каждому игроку дается возможность управлять танком случайного цвета (необязательно уникального) на игровом виртуальном поле. Танк умеет ездить (move), поворачивать "головой" (headAngle) и стрелять (shoot).

"Здоровье" танка - число от 0 до 1. Обычно урон одной пули 0.25, но если подобрать бонус элитной аммуниции, то урон возрастет до 0.5, т.е. полностью новый танк можно уничтожить за четыре обычных выстрела, или два бонусных. Единственная возможность пополнить здоровье - бонусы "аптечки", которые чинят танк на 0.5 в течении 10 секунд.

Чтобы подняться в таблице рекордов, необходимо набрать как можно больше очков. Очки даются за уничтожение танка противника. Первое уничтожение - +100 очков, следующее - +125, +150, +175, смерть - счётчик сбрасывается и за следующее убийство дадут снова +100 очков.

## Код

### Входные данные

Ваша задача, в первую очередь, написать функцию `onTick()`. Она может принимать один аргумент - данные игрового поля в виде объекта. Также в глобальном окружении вам даны четыре константы: **[number]** width, **[number]** height, **[number]** tankRadius и **[array]** walls. Ширина, высота и радиус танка - это количество условных единиц, не пикселей. walls - (стены; массив массивов с двумя точками стены)
Пример:

	[
			[{x: 7.5, y: 2.5}, {x: 2.5, y: 2.5}],
			[{x: 2.5, y: 2.5}, {x: 2.5, y: 7.5}],
			[{x: 2.5, y: 12.5}, {x: 2.5, y: 17.5}],
			[{x: 2.5, y: 17.5}, {x: 7.5, y: 17.5}]
	]

Заметьте, что указан tankRadius. На сервере танк - это окружность и все вычисления с танками выполняются, как вычисления с кругами. Это сделано для более простого поворота и просчета колизий (столкновений), чтобы танк не застрял в стене, повернувшись мгновенно на Х градусов и не зацепил стену углом квадрата.

Далее идет перечисление всех ключей и значений, которые вы можете найти в данном аргументе. Не стоит бояться столь большого их количества, многое из этого вам может не понадобиться.

Вы также можете "пощупать" данные в консоли, введя `lastData` и получив последний ответ сервера.

* * * 

**[object]** data

- **[number]** time // номер "тика"/кадра
- **[object]** me (данные о вашем танке)
    - **[number]** x (от 0 до width)
    - **[number]** y (от 0 до height)
    - **[number]** hp (здоровье, от 0 до 1)
    - **[string]** username (ваш юзернейм, вдруг вы забыли)
    - **[string]** color (цвет танка)
    - **[number]** lastShot (кол-во тиков с последнего момента выстрела; если == 16, то можно стрелять)
    - **[object]** bonuses (активные бонусы)
    	- **[boolean]** heal (бонус "аптечка")
    	- **[boolean]** ammo (бонус элитной аммуниции)
- **[array]** enemies (данные о вражеских танках)

	[{

	- **[number]** x (от 0 до width)
	- **[number]** y (от 0 до height)
	- **[number]** vx (X-координата вектора езды)
	- **[number]** vy (Y-координата вектора езды)

	Чтобы узнать, где был танк в прошлом кадре, достаточно воспользоватся вектором:

		lastX = enemy.x - enemy.vx
		lastY = enemy.y - enemy.vy

	- **[number]** hp (здоровье, от 0 до 1)
	- **[number]** angle (поворот танка, в радианах)
	- **[number]** headAngle (поворот дула танка, в радианах)
	- **[string]** username (юзернейм владельца вражеского танка)
	- **[string]** color (цвет вражеского танка)
	- **[number]** lastShot (время, номер "тика" последнего выстрела)
    - **[object]** bonuses (активные бонусы; аналогично с me)
    	- **[boolean]** heal (бонус "аптечка")
    	- **[boolean]** ammo (бонус элитной аммуниции)

	},...]

- **[array]** bullets (данные про пули)

	[{

	- **[number]** x (от 0 до width)
	- **[number]** y (от 0 до height)
	- **[number]** vx (X-координата вектора полёта)
	- **[number]** vy (Y-координата вектора полёта)

	Чтобы предсказать, где будет пуля на следующем кадре, достаточно добавить к координатам вектор. 

		newX = bullet.x + bullet.vx
		newY = bullet.y + bullet.vy

	Если умножать вектор на 2, 3..., то можно узнать, где будет пуля через 2, 3... кадра (если она не столкнется со стеной)
	
	- **[number]** angle (угол полёта пули, в радианах)
	- **[string]** owner (юзернейм владельца пули)
	- **[string]** color (цвет пули)
	- **[boolean]** type (false - обычная, true - элитная)

	},...]

- **[array]** bonuses (неподобранные бонусы)
	
	[{

	- **[number]** x (от 0 до width)
	- **[number]** y (от 0 до height)
	- **[number]** radius (радиус, при котором бонус подберётся)
	- **[string]** type (тип бонуса, "heal" или "ammo")

	},...]

### Выходные данные

Ваша функция `onTick` должна возвращать объект с тремя ключами:

- **[number]** headAngle (угол поворота башни танка, в радианах)
- **[boolean]** shoot (стрелять ли (в направлении headAngle, который вы указали в этом объекте))
- **[array]** move (вектор движения танка)

move - массив с двумя числами: X и Y координаты вектора движения. Ниже можно увидеть видео, где A - это вектор.

Пример:
	
	[0.8660254, -0.499999]

Максимальная скорость - 1, т.е. макс. длина вектора - 1.

{VIDEO}

**Подсказка**: не трудно заметить, что на видео точка вектора едет по кругу, т.е. чтобы запустить наш танк в каком-то направлении мы должны найти точку на окружности на таком-то углу. Чуть дальше есть несколько формул из геометрии, возможно они вам помогут.

{WARN_START}**Будьте внимательны!**

Отсчет игрового поля начинается слева сверху (т.е. (0, 0) точка - слева сверху), поэтому на видео вы видите ось Y направленую вниз.
{WARN_END}

## Дополнительно

Можно дебажить прямо на игровом поле! Для этого есть четыре функции:

- `line(from, to, (optional) color)` Рисует линию.
- `point(your_point, (optional) color)` Рисует точку.
- `circle(center, radius, (optional) color)` Рисует окружность.
- `text(string, point, (optional) color)` Рисует текст.

Если не выбрать цвет, линия/точка/круг будут красными.
Аргументы (кроме радиуса, цвета и текста) должны быть объектами с ключами **x** и **y**. Все аргументы должны быть условными единицами и должны отталкиваться от констант width и height, поэтому можно легко функции указать себя (`data.me`) или пулю (`data.bullets[0]`) прямо "с коробки". Например:

	line(me, enemy);
	line(bullet, me);

	circle(me, tankRadius);

	point({x: width/2, y: height/2});
	point(bullet);



Также, для удобства, все функции в **Math** можно писать без **Math.**. Например:

	sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));
	point({x: width/2 + cos(PI/4)*10, y: height/2 + sin(PI/4)*10});

## Геометрия

Шпаргалка формул из геометрии.

- **Расстояние между двумя точками.** ![](assets/1.png)
	
	**Теорема Пифагора**: сумма квадратов катетов равна квадрату гипотенузы.

	Если нарисовать между точками прямоугольный треугольник (как на картинке), то гипотенуза - это и будет расстояние. Катеты можно найти разницами координат. В итоге мы получаем такую формулу:

	![](assets/1_formula.png)

- **Точка на окружности.** ![](assets/2.png)

	Допустим, у нас есть окружность радиусом 2 (R=2) и центром в точке (0, 0). Тогда, чтобы найти точку на круге на определенном углу (в js: в радианах), мы можем воспользоваться этой формулой:

	a - угол (в радианах), на которой будет точка.

	![](assets/2_1formula.png)

	Но, если центр окружности не на (0, 0), то стоит дополнить эту формулу, где с(x) и c(y) - центр круга.

	![](assets/2_2formula.png)

- **Угол между двумя точками** ![](assets/3.png)

	Допустим, у нас есть две точки: a и b. Наша задача - найти угол между ними, чтобы, например, навести дуло танка на врага. Опять таки, рисуем прямоугольный треугольник. Давайте вспомним, что такое тангенс:

	**Тангенс угла (tg)** — отношение противолежащего катета к прилежащему катету.

	Это нам поможет, но лишь частично - нам наоборот нужен угол, а не отношение. Поэтому вспоминаем **арктангенс (arctg)**, функцию, обратной тангенсу.

	Но, сразу скажу, что arctg может работать правильно только в 1 и 4 четвертях, поэтому лучше использовать функцию в программировании - `atan2`. Она принимает в аргументы длины катетов, поэтому ей нужно дать разницу координат. В итоге у нас получается это:

		atan2(a.y - b.y, a.x - b.x)

	Будьте готовы к тому, что функция вернет угол в радианах.

- Что еще стоит загуглить:
	- Пересечение двух линий
	- Пересечение линии и окружности
			</div>
			<script type="text/javascript" src="/lib/markdown.js"></script>
			<script type="text/javascript">
				var docs = document.querySelector("#docs");
				docs.innerHTML = toHTML(docs.innerHTML).replace(/{VIDEO}/g, "<video loop autoplay muted style='width:150px'><source src='assets/explanation.mp4' type='video/mp4'></video>").replace(/\<a /g, "<a target='_blank' ").replace(/{WARN_START}/g,"<div class='warning'>").replace(/{WARN_END}/g,"</div>").replace(/formula\.png\"/g, "formula.png\" class='formula'").replace(/formulaE\.png\"/g, "formulaE.png\" class='formulaE'")
			</script>
			<div class='section' id='client'>
				<h3>Вам надоел браузер? <span style='text-decoration: line-through;'>Или может JS?</span></h3>
				<p>Писать в браузере код - это удобно, и мы никогда не уберем такую возможность. Однако все же браузер имеет свои недостатки. Например, вам необходимо держать вкладку всегда открытой и даже переключение на другую будет вызывать заметные задержки.</p>
				<p>Но и клиент не идеален. В данном случае это консольное приложение, поэтому дебаг функции не будут отображаться. Мы рекомендуем воспользоваться клиентом, когда код бота уже готов.</p>
				<h3>Инструкция</h3>
				<p>1. <b>Для начала вам нужно на этой странице переключить режим из игрока в зрителя.</b> Дело в том, что клиент, как отдельный игрок, который управляет танком, может быть подключен только один, а как зритель - неограниченное кол-во</p>
				<div class='btn long ripple' id="switch-to-spectator" onclick="addQueryParam('type','spectator')">Стать зрителем</div>
				<div class='btn long ripple' id="switch-to-player" onclick="addQueryParam('type','player')">Стать игроком</div>
				<p>2. <b>Скачайте и запустите клиент.</b></p>
				<ul>
					<li>
						<p><a href="clients/js-v1.1.zip">JS Client v1.1 (7.7KB)</a></p>
						<p>Требуется NodeJS и NPM. Предварительно нужно установить библиотеки (install.sh/install.bat или "npm install").</p>
						<p>Учетные данные хранятся в config.json. При его отсутствии клиент сам спросит логин и пароль/токен и заполнит его.</p>
					</li>
					<li>
						<p><a href="clients/java-v1.0.zip">Java Client v1.0 (1MB)</a></p>
						<p><a href="clients/kotlin-v1.0.zip">Kotlin Client v1.0 (0.9M)</a></p>
						<p>Проект на Gradle. Альфа-версия. Возможна аутентификация только по логину и паролю, указанным в коде.</p>
					</li>
				</ul>
				<p>3. <b>Для аутентификации введите данные для входа.</b> Вы можете сразу ввести свой ник и пароль, либо, взять gameSessionToken вместо пароля.</p>
				<span  id='gameSessionTokenSpan'>Ваш gameSessionToken: </span>
				<input type="password" id='gameSessionToken' value="" disabled><span class='btn ripple' id='visible' onclick="
					var tokenInput = document.querySelector('#gameSessionToken');
					tokenInput.type = tokenInput.type == 'password' ? '' : 'password';
					this.id = tokenInput.type == 'password' ? 'visible' : 'visible-off';
				"></span>
			</div>
			<div class='section' id='scoreboard'>
				<table>
					<tbody>
						<tr>
							<th>Место</th>
							<th>Никнейм</th>
							<th>Очки</th>
						</tr>
					</tbody>
					<tbody>
					</tbody>
				</table>
			</div>
		</div>
		<div id="control-panel">
			<div class='btn ripple' id="play">
			</div>
			<div class='btn ripple' id="pause">
			</div>
		</div>
	</div>
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.3/ace.js"></script>
	<script type="text/javascript">
		const gameName = 'tanks';
		const defaultCode = '// constants: width, height, tankRadius, walls\n// this function is run every tick\n\nfunction onTick(data) {\n\n\treturn {\n\t\tmove: [0, 0],\n\t\theadAngle: Date.now()/1000*PI,\n\t\tshoot: true\n\t}\n}';
		const needToConnect = true;
	</script>
	<script src="../ripple.js" type="text/javascript"></script>
	<script src="renderer.js" type="text/javascript"></script>
	<script src="logic.js" type="text/javascript"></script>
	<script src="../game-main.js" type="text/javascript"></script>
</body>
</html>